大家好 欢迎来到 Python手搓神经网络系列教程的第12集 今天我们讲需求函数 上一节我们讲了损失函数 通过损失函数可以计算出 神经网络它运算的结果有多大误差 但是光有误差还不行 我们还得知道如何调整网络 调整的过程就是通过反向传播 算法来进行的 而需求函数就是反向传播算法的 起点 因为它定义了最后一层的 函数值应该怎么变 那么我们为了解释需求函数 先看一下 神经网络的最后一层 它是怎么运作的 我们看神经网络 它会有 很多个权重 这些权重是从前一层的 输出来的 前一层前面有很多层 然后w1 w2 w3 w4等等 然后所有这些值 都汇总到一个值 再加一个偏至值 就得到一个数值 我们管这个数值叫z 这个数值会再通过一个激活函数 通过一个激活函数 然后就得到一个output 输出值 output 这个输出值 它的公式是这样的 因为前面的输入值 可能有a1 a2 a3 a4这样 a1xwe加arxw2 等等 一直加到 anxwn 然后再加上一个偏至值 这样加好了之后 它就等于z z就是这来的 然后z再经过一个激活函数 也就是最后output output我们就管它叫o 这个o它就等于fz 这个f其实就是我们之前讲过的softmax 我们神经网络它有两个输出值 这个输出值是output1 我们还有另外一个同样的节点 在这 然后它生成一个output2 那个节点咱们就省略了 咱们就写在这 output2 但是我们在这个pattern里一般管 第一个叫output0 这个叫output1 是这两个 最后生成的输出值 它就是一个向量的形式 就是这样 我们管它叫output1 不是output0 这个叫output0 这output也太小了 画大一点 output0 output1 这样 这样就是一条输出值了 这个输出值 我们就要跟标签值 相比较 标签值它也是 有两个 值组成的 比如我们标签值是01的话 我们就要比较它这两个是不是相似 假如说我们这个是 0.3 0.7 如果是0.3 0.7的话 那就是右边值大 经过45入之后 其实左边就是0 右边就是1 所以这个计算结果 分类的结果 跟右边这个值是一样的 我们之前已经有 classify这个函数 就是左边这个函数 这个函数其实就是一个45入的 所以我只要右边这个值大于0.5 它最后就变成1 就会跟标签值一致 如果一致的话 我们就不需要去调整它的权重了 所以如果这两个值一致 最的值就不需要调整 就是这样 因为我们有我们需求函数 它指的是什么 指的是最的值 希望它往哪里变 最值 需要怎么变 需要怎么变 无非有三种变法 一种是减小 一种是不变 一种是增加 那么我们给这个函数 就是如果需要这个最值减小的时候 我就给它复一个-1 如果它不需要改变的话 这个函数就是0 如果它需要增加的话 那就给它复值是1 所以我们就给它复一 然后我们就给它复一 然后我们就给它复一 然后我们就给它复一 然后我们就给它复值是1 在这个例子里边 因为我们看这是0.3 这是0.7 那它就不需要改变 这时候我们需求函数就要返回一个0 就要返回一个0值 如果是反过来了 如果是0.7 0.3了 那它就需要改变了 这时候需要返回一个什么值 我们就看这个情况了 你看这里是0 这是这里是1 但我们的结果是左边比右边大 所以这个值需要减小 这个值需要增加 所以我们这时候返回的值 就是一个向量 左边这个值需要减小就是-1 右边这个值需要增加 就是正义 而这个其实也返回的是一个向量 就是00的向量 就是这样 因为它不需要改变 我们两边的值都是0 就都不要变 这样就是左边是-1 右边是正义 如果我们的标准答案是这样的 标准答案是10 但是我们的结果还是0.3 0.7 这个又不对了 因为10是左边的大 但是这个计算结果是右边的大 我们左边这个需要增加 右边这个需要减少 这种情况下 我们需要返回的值 就是正义和负义 这样通过这个函数 我们比较 神经网络最后一层的运算结果 和标准答案之间的区别 就可以计算出 哪一个值需要增加 哪一个值需要减小 然后生成一个这样的 修改值的矩阵 我们就管它叫做需求函数 因为计算的是这个值是需要 怎么变的 然后再把需求函数一层一层的 反向传播到前面 这样每一层的偏质和权重的 值都根据这些需求值来修改 修改之后 这网络就被优化了 好 我们现在就开始写这个函数 需求函数 对定义一个需求函数 我们管这个需求函数叫 get final layer preact demand 这个函数名有点长 因为我们在编程的时候 为了让自己记住这个函数是干嘛的 所以最好就是把它的功能全写上 get final layer 就是最后一层 因为这个函数只适用于最后一层 前面的层就不需要了 后面我们会讲之前的层 这些需求的值怎么得来 其实是通过反向传播得来的 所以它只对最后一层有效 所以叫get final layer preact demands preact的意思就是 在激活函数之前 我们这个z这个值不是在激活 函数之前 叫preact demands 就是需求 在最后一层的激活函数之前的值 需要怎么变 就是这个意思 需要怎么变 我们首先得知道输入的什么 输入的仍然是两个值 一个是predicted values 就是预测到的值 预测值 predicted values 还有 target vector 这target vector 其实就是相当于这么一个real 这个值 就是真实的值 真实的值也就是目标值 对吧 因为我们就是要让我们函数 它最后算出来的值 跟真实的值一样 所以我们就以真实的值 作为目标来计算 所以我们就管叫target vector 其实你真正输的时候 就是真实的值 也就是打的标签的值 我们这两个都有了 然后我们还是经过 这样的计算 target 这是一个矩阵 它就等于 np.zeros 然后 还是 再来一层括号 咱们上一次编的时候 就少了一层括号 这次不能忘了 len长度 target vector 然后道号2 我们看这里 这里我们这一句 其实跟上次编的损失函数 完全一样的 我们就是要构造一个 构造出来一个形状 是这么多行 这么多列 然后全都是0的 一个矩阵 也就是构造这个矩阵 构造出这个矩阵来 然后 我们再给它复制 target 这个少了一个 多了一个亿 还是这样 跟上面这个很像 冒号1 这就是所有行的第一列 第一列我就给它复制 就复什么值 就是target vector 也就是把它的项量 直接复进来 然后下面这个 我就甚至可以直接从前面 前面来复制一下 因为都是一样的 看我们这个函数的前三行 跟前面这个函数的前 前三行 这都一样 都没有区别 因为我们做的都是同样的事 都是把这个 项量变成一个矩阵 填充 填充成一个矩阵 这部分完成了 后面就不一样了 后面我们用一个循环 for i in range 也就是我 因为它是这些数据 它有很多条 我们有几 有多少条就循环几次 对于每一条都做同样的操作 就是if np.dot做一个点成 target i 和predict values 这两个做点成 我们就判断它是不是大于0.5 这一行 这一行做的判断 其实就是右边 我们刚才做的计算 这一行 现在高亮了这一行 就这一行 它做的判断 其实就是右边我们 你看我也是0.3×0 加上0.7×1 最后就等于0.7 等于0.7 现在它就是大于0.5 大于0.5 就说明它是准的 准的话我们就返回0 我们就不需要再对它进行调整了 我们就返回就是00 00的意思就是不调整的意思 所以我们这个地方就返回的就是00 我们就这样写 target i 这里我们就需要的 它就等于00就行了 所以我们就写np.ir 我给它附一个00的值 我不管之前它是什么值 我就要让它等于00 因为我们已经算了 它大于0.5 我不需要修改了 那还有需要修改的情况 else 如果 就是后面的情况 这一行就是else 就是如果它不是这样的 是什么样的 像这样0.7 0.3 我跟他一算 最后得出来的结果 就是小于0.5 0.7×0 加0.3×1 最后结果等于0.3 小于0.5 就说明 这个结果不准 不准 我们就要把它变成一个这样的 或者这样的 或者是-1到1 或者是1到-1 怎么变 我们就这么写 还是给它复制 它就等于 这个值 它减去0.5 整体扩起来 再乘以2 这有同学可能问了你 这是搞啥 这什么意思 什么叫-0.5×2 我们观察一下右边这个图 这里有两种需要返回 非0值的情况 一种就是如果 目标的 值是0和-1 它就要返回-1和1 不对 如果目标值是0和1 它就需要返回-1和1 如果目标值是1和0 它就要返回1和-1 我们发现有一个规律 目标值里的1 它都没有变 它都还是1 只是把0变成了-1 而这里也是1没变 还是以0变成-1 我们-0.5×2就变成什么了 我们看这个 0 1 我给他减0.5之后 它就变成-0.5和正0.5 然后再给乘以2之后 就变成-1和正1了 正好是我们想要的结果 如果是10 同样的道理 10 我减去0.5之后 它就变成 0.5和-0.5 然后再以乘以2的话 再乘2 它就变成了1和-1 又是我们想要的结果 所以我们只要通过这么一个运算 就可以把目标的 函数的值 就变成了我们想要 需求函数的值 就这样 就可以了 然后我们再把它返回 我们只要把target 这个值返回就行了 好 这个函数就编好了 我们放到测试的模块里去试一下 看看它能不能运行 这是测试模块 这个就是需求函数 我们打印的就是这个 看一下 嗯 试一下运行 这还有一个错误 哎 少了个帽号 好 把帽号加上了 运行 嗯 我们看一下 10101 这是10101 我们得到的是0-100-1 看看对不对 第1个 1 看这个是 predicted value 就是预测值 目标只是1 它右侧这个就是1 嗯 看来是对的 所以说第一行不需要调整 就是0 第二行 0.5 因为它的值没有大于0.5 它是等于0.5 还是需要调整的 怎么调 我们看这是0 也就是说我需要把这个值调小 这个值调大 对左边是1 右边是-1 这个是对的 然后这个不需要调 因为这里是1 这个0.8比0.5大 好 这个是0 这个0.3 这也不需要调 这个是1 这个是0.1 这就需要调了 所以这个应该是左边是-1 右边是正义 嗯 我们可以看出 这个就是我们所要的 需求值的矩阵 它其实就指的是 最后一层有两个神经元 这两个神经元 它需要怎么调 从这看 我们需求函数 就已经编好了 我们把它再复制回原来的位置 现在这个需求函数就成功了 我们把它放到网络里去运行看一下 你看我们前一个算了 损失函数 我们再算一下需求函数 demand 就等于 我们需要的函数 我们再算一下需求函数 我们再算一下需求函数 我们再算一下需求函数 嗯 右边这可以照抄 它是一样的 这怎么target 这写的不对 我看一下 拼写错误 这里 这里是万恶之源 这呢 target 嗯 我们找一下 所有target位置都需要改 好 好了 我们也把它给打印出来看一下 这应该叫demand附属 因为它有很多个值 好运行 这个是正确的分类 这个是训练之前的分类 看我们的值 这就出来了 仍然是这个结果 都是0 都是0 这个就是这个demand 也就是我们这个需求 矩阵 这个需求矩阵都是0的意思 就是都预测对了 都预测对了 就不用再修改了 那怎么看都预测对了 你看这都是小于0.5的 损失函数都很小 所以它是相符的 但是你也许看出来了 虽然计算的结果显示 预测都是准的 但实际上它并不准 你看我们刚开始的数据 它的标准答案是10 是01010 这是标准答案 但是我们运算出来的结果 是11111 它不一致 它不一致 为什么它算出来的是一致了 而且我们看它最后打印的 target 它变成了11111 也就是跟原来的值不一样了 这个到底发生了什么 我们看一下代碼 在这里 你看target等于标准答案 我们就已经把这标准答案拿到了 是吧 但是问题是 我们在这对data进行了修改 修改了之后 我们之前的target得到的值也变了 为什么 因为target其实它并没有建立一个 新的地址和新的变量 它只是拿到了数据中的一列 当data数据的一列变化了之后 它也跟着变了 这变了之后 它也跟着变了 所以就导致你预测的总对 因为它变了之后 这个值它也变了 那肯定是对的 我们来演示一下 这是男派当中需要注意的一个问题 你看我们现在这个就是标准答案 我们就打算它之前的数据 我们先把这个数据打印出来 然后再用这个数据 获得 拿到predicted的 第一列 也就这一列 然后我们再打印出来 然后我们把它改了一下 再打印 我们看一下 看这个就是predicted的值 然后我们取它的第一列 就是10.5 0.8 0.3 0.1 你看是对的 是对的 但是我们把它的这一列都复成0之后 我们再去打印同样的内容 它就变了 也就是说我们看起来是同样的内容 而且好像它也没有变 但其实跟着这个值的变化 它也变了 怎么避免这个情况 我们就需要用到一个copy的 copy的库 import copy 然后我们在这里在取值的时候 我不能直接这样就取它的这一列 取它的这一列 最后结果就是它的列变化之后 这个值会跟着变 我们用copy复制 copy 点 deep copy 然后括号 这样就行了 看一下 你看 这不变了 虽然后来我把它的值都改成了0 但是这个值没有跟着变 因为这它已经是它的一个复制了 所以在主程序中我们也这么做 我们也是在这里 跟它一样 import copy import copy之后 我们在下面就用这个 target不这样等 我们就这么写 copy 点 deep copy 然后括号 把它给扩起来 这样我们这个值就不会跟着变了 好运行一下 这个是正确的分类 这个是 训练前的分类 我们看 这回 这正确的分类跟网络运算的分类就不一样了 网络运算的结果都是0 但是正确的分类有两个1 也就是说 在第二条和第5条数据 这个网络 神经网络运算错了 我们看一下 返回的值 我们把01001扩展成一个矩阵 就是01001 这里是对的 然后我们知道第二条和第5条需要修改 我们看 这个就是需求矩阵 正好第二条需要修改 第5条需要修改 而且我们看损失函数 第二条0.9 这个损失值很大 也就是误差很大 第5条0.8 这个也是误差很大 但那三个对的 你看误差都非常小 所以我们在这里就可以看见我们的 损失函数 和需求函数 这两个函数都是正确运行了 我们现在这两个函数已经都做好了 下一步该怎么做 下一步我们就要给他反馈了 你看我们有网络 这里有一个网络 就这样 这两个值我们已经知道了 是输出值O1 O2 然后他的进口函数之前 分别叫Z1和Z2 我们通过需求函数 就可以知道 这个Z1 Z2 我们需要他怎么变 比如Z1 他需要增加 这个Z2需要减少 那么我们就给他附一个值 比如增加的 我就给他附一个正义 然后这个就是负一 我就用这个需求值 去和前面的这些值做运算了 比如这有一个A1 这有一个A2 这有一个A3 需求值其实就是什么值 他就是相对于 损失函数的相反数 就相当于他的需求值是-1的意思 就是 Z Z DZ比成DL 他的值的相反数 因为什么 因为损失函数是越小越好 我们这个要求是越大越好 所以他等于-1的意思 就是其实是他大于0 而这个等于正义的意思 就是这个 这是Z2 就是他的 Z1比Z2 比成L 他是小于0 其实我们就相当于是已经把 我们这些值跟目标函数的 之间的 导数已经给了 但是这导数 我们就只用正义和负一来表示 因为我们只需要知道 他是需要增加和减少就可以了 然后前面就会用之前 我们这个练试法则的方法来做 因为我们知道 A1xWE不就等于Z1吗 就这样是吧 对 A1xWE 这是WE 就等于Z1 然后我们跟随着导数 就是之前我们讲过的这种方法 然后我们求 WE对他的导数 那就等于A1再乘以 乘以Z1对于他的导数 就这样通过这个办法来算 这样我们就可以在一个层里进行 反向传播了 至于具体怎么传播 我们就下集再讲 本集就先讲到这里 好 谢谢大家收看 再见 